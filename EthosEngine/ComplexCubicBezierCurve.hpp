#pragma once
#include "pch.hpp"
#include <vector>
#include <glm/gtx/intersect.hpp>

enum class CurveControlMode { linear = 0, smooth, free };

class ComplexCubicBezierCurve {

public:
	std::vector<glm::vec3> points;
	std::vector<CurveControlMode> controlModes;

	glm::vec3 interpolate(float t) const {
		t = fmax(fmin(t, 1.f), 0.0f);
		t *= ((points.size() - 4) / 3) + 1;

		// first, determine segment
		size_t seg = (size_t)t;
		t -= seg;

		if (seg > (points.size() - 4) / 3) {
			seg = (points.size() - 4) / 3;
			t = 1.f;
		}

		// Apply cubic bezier formula
		float i = 1 - t;
		return i * i * i * points[seg * 3 + 0]
			+ 3 * i * i * t * points[seg * 3 + 1]
			+ 3 * i * t * t * points[seg * 3 + 2]
			+ t * t * t * points[seg * 3 + 3];
	}

	glm::vec3 derivative(float t) const {
		t = fmax(fmin(t, 1.f), 0.0f);
		t *= ((points.size() - 4) / 3) + 1;

		// first, determine segment
		size_t seg = (size_t)t;
		t -= seg;

		if (seg > (points.size() - 4) / 3) {
			seg = (points.size() - 4) / 3;
			t = 1.f;
		}

		// Apply cubic bezier derivative formula
		float i = 1 - t;
		return 3.f * (
			i * i * (points[seg * 3 + 1] - points[seg * 3 + 0])
			+ 2 * i * t * (points[seg * 3 + 2] - points[seg * 3 + 1])
			+ t * t * (points[seg * 3 + 3] - points[seg * 3 + 2]));
	}

	size_t getNumSegments() const {
		return ((points.size() - 4) / 3) + 1;
	}

	float getTClosestToPoint(glm::vec3 point) {
		float minT = 0.0f;
		float minDist2 = glm::length2(interpolate(minT) - point);

		for (size_t i = 1; i < 100; ++i) {
			float newT = i / 100.0f;
			float newDist2 = glm::length2(interpolate(newT) - point);
			if (newDist2 < minDist2) {
				minT = newT;
				minDist2 = newDist2;
			}
		}
		return minT;
	}

	static glm::vec3 lerp(glm::vec3 v0, glm::vec3 v1, float t) {
		return (1 - t) * v0 + t * v1;
	}

	static void subdivideCubicBezier(float t,  const glm::vec3& p0, const glm::vec3& p1, const glm::vec3& p2, const glm::vec3& p3,
		glm::vec3& q0, glm::vec3& q1, glm::vec3& q2, glm::vec3& q3) {
		// Use De Casteljau's algorithm to split the curve
		glm::vec3 p01 = lerp(p0, p1, t);
		glm::vec3 p12 = lerp(p1, p2, t);
		glm::vec3 p23 = lerp(p2, p3, t);

		glm::vec3 p012 = lerp(p01, p12, t);
		glm::vec3 p123 = lerp(p12, p23, t);

		glm::vec3 p0123 = lerp(p012, p123, t);

		// Calculate the new control points for the subset curve
		q0 = p0;
		q1 = p01;
		q2 = p012;
		q3 = p0123;
	}

	ComplexCubicBezierCurve getFirstOfSplit(float t) {
		// first, determine segment
		t = fmax(fmin(t, 1.f), 0.0f);
		t *= ((points.size() - 4) / 3) + 1;
		size_t seg = (size_t)t;
		t -= seg;
		if (seg > (points.size() - 4) / 3) {
			seg = (points.size() - 4) / 3;
			t = 1.f;
		}

		// Work ot that points of the segment that was split:
		glm::vec3 p0, p1, p2, p3;
		subdivideCubicBezier(t, points[seg * 3 + 0], points[seg * 3 + 1], points[seg * 3 + 2], points[seg * 3 + 3], p0, p1, p2, p3);

		// Then, if this is the first segment; just return a the curve generated by the subdivide function
		if (seg == 0) {
			return ComplexCubicBezierCurve(p0, p1, p2, p3);
		}
		// Otherwise, add all previous segments first, before adding the last three point generated.
		else {
			ComplexCubicBezierCurve newCurve = ComplexCubicBezierCurve(points[0], points[1], points[2], points[3]);
			for (size_t i = 1; i < seg; ++i) {
				newCurve.extendCurve(points[i * 3 + 1], points[i * 3 + 2], points[i * 3 + 3]);
			}
			newCurve.extendCurve(p1, p2, p3);
			return newCurve;
		}
	}

	ComplexCubicBezierCurve getSecondOfSplit(float t) {
		// first, determine segment
		t = fmax(fmin(t, 1.f), 0.0f);
		t *= ((points.size() - 4) / 3) + 1;
		size_t seg = (size_t)t;
		t -= seg;
		if (seg > (points.size() - 4) / 3) {
			seg = (points.size() - 4) / 3;
			t = 1.f;
		}

		// Work out the points of the segment that was split:
		glm::vec3 p0, p1, p2, p3;
		subdivideCubicBezier(1-t, points[seg * 3 + 3], points[seg * 3 + 2], points[seg * 3 + 1], points[seg * 3 + 0], p3, p2, p1, p0);

		// Then, if this is the last segment; just return a the curve generated by the subdivide function
		if (seg + 1 == getNumSegments()) {
			return ComplexCubicBezierCurve(p0, p1, p2, p3);
		}
		// Otherwise, add generated points, then any segments following it:
		else {
			ComplexCubicBezierCurve newCurve = ComplexCubicBezierCurve(p0, p1, p2, p3);
			for (size_t i = seg + 1; i < getNumSegments(); ++i) {
				newCurve.extendCurve(points[i * 3 + 1], points[i * 3 + 2], points[i * 3 + 3]);
			}
			return newCurve;
		}

	}

	glm::vec3 getStartPoint() const {
		return points[0];
	}

	glm::vec3 getEndPoint() const {
		return points.back();
	}

	glm::vec3 getStartTangent() const {
		return glm::normalize(points[0] - points[1]);
	}

	glm::vec3 getEndTangent() const {
		return glm::normalize(points.back() - points[points.size() - 2]);
	}

	

	void extendCurve(glm::vec3 control_1, glm::vec3 control_2, glm::vec3 end, bool atStart = false) {
		if (atStart) {
			points.push_back({});
			points.push_back({});
			points.push_back({});
			controlModes.push_back({});
			controlModes.push_back({});
			controlModes.push_back({});

			// shift all points and controlmodes by 3.
			for(size_t i = points.size() - 3; i > 0; --i) {
				points[i + 2] = points[i - 1];
				controlModes[i + 2] = controlModes[i - 1];
			}

			points[0] = end;
			points[1] = control_2;
			points[2] = control_1;

		}
		else {
			points.push_back(control_1);
			points.push_back(control_2);
			points.push_back(end);
			controlModes.push_back({});
			controlModes.push_back({});
			controlModes.push_back({});
		}
		
	}

	void attachCurve(glm::vec3 control_1, glm::vec3 control_2, const ComplexCubicBezierCurve& other) {
		extendCurve(control_1, control_2, other.points[0]);
		for (size_t seg = 0; seg < other.getNumSegments(); ++seg) {
			extendCurve(other.points[3 * seg + 1], other.points[3 * seg + 2], other.points[3 * seg + 3]);
		}
	}

	void attachCurveAutomatic(const ComplexCubicBezierCurve& other) {
		// calculate the interesection following the tangents of the start and end points
		glm::vec3 intersectionPoint;
		glm::vec3 p1 = getEndPoint();
		glm::vec3 p2 = other.getStartPoint();
		
		glm::vec3 v1 = getEndTangent();
		glm::vec3 v2 = -other.getStartTangent();

		glm::vec3 p1p2 = p2 - p1;

		float det = (v1.x * v2.y) - (v1.y * v2.x);
		if (det == 0) {
			intersectionPoint = 0.5f * (p1 + p2);
		}
		else {
			float t = (p1p2.x * v2.y) - (p1p2.y * v2.x) / det;
			intersectionPoint = p1 + v1 * t;
		}
		
		float smoothingFactor = 0.5f;
		attachCurve(lerp(intersectionPoint, p1, smoothingFactor), lerp(intersectionPoint, p2, smoothingFactor), other);
	}

	void reverse() {
		CurveControlMode modeSwap;
		glm::vec3 pointSwap;

		for (size_t i = 0; i < points.size() / 2; ++i) {
			pointSwap = points[i];
			points[i] = points[points.size() - 1 - i];
			points[points.size() - 1 - i] = pointSwap;

			modeSwap = controlModes[i];
			controlModes[i] = controlModes[controlModes.size() - 1 - i];
			controlModes[controlModes.size() - 1 - i] = modeSwap;
		}
	}

	ComplexCubicBezierCurve(glm::vec3 start, glm::vec3 control_1, glm::vec3 control_2, glm::vec3 end) {
		points.push_back(start);
		points.push_back(control_1);
		points.push_back(control_2);
		points.push_back(end);
		controlModes.push_back({});
		controlModes.push_back({});
		controlModes.push_back({});
		controlModes.push_back({});
	}
};