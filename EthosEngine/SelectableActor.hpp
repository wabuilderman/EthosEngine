#pragma once
#include "Actor.hpp"
#include "Mesh.hpp"
#include <limits>

enum class SelectionColliderMode { disabled, sphere, mesh };

class SelectableActor : public Actor {

	bool selectState = false;
	bool mouseoverState = false;
	bool dragable = true;
	bool dragState = false;

	// Function generated by ChatGPT
	static float rayTriangleIntersect(const glm::vec3& orig, const glm::vec3& dir,
		const glm::vec3& v0, const glm::vec3& v1, const glm::vec3& v2)
	{
		const float EPSILON = 0.000001f;
		glm::vec3 edge1, edge2, h, s, q;
		float a, f, u, v, t;

		edge1 = v1 - v0;
		edge2 = v2 - v0;

		h = glm::cross(dir, edge2);
		a = glm::dot(edge1, h);

		if (a > -EPSILON && a < EPSILON)
			return std::numeric_limits<float>::quiet_NaN(); // This ray is parallel to this triangle.

		f = 1.f / a;
		s = orig - v0;
		u = f * glm::dot(s, h);

		if (u < 0.f || u > 1.f)
			return std::numeric_limits<float>::quiet_NaN();

		q = glm::cross(s, edge1);
		v = f * glm::dot(dir, q);

		if (v < 0.f || u + v > 1.f)
			return std::numeric_limits<float>::quiet_NaN();

		// At this stage, we can compute t to find out where the intersection point is on the line.
		t = f * glm::dot(edge2, q);

		if (t > EPSILON) // ray intersection
			return t;

		return std::numeric_limits<float>::quiet_NaN(); // This means that there is a line intersection but not a ray intersection.
	}

public:

	SelectionColliderMode colliderMode = SelectionColliderMode::sphere;
	float colliderMeasure1 = 1.f;
	Mesh* colliderMesh = nullptr;

	float ComputeRaycastDist(const glm::vec3& rayOrigin, const glm::vec3& rayDirection) {
		if (colliderMode == SelectionColliderMode::sphere) {
			glm::vec3 oc = rayOrigin - transformComponent->getGlobalTransform().getPosition();
			float a = glm::dot(rayDirection, rayDirection);
			float b = 2.0f * glm::dot(oc, rayDirection);
			float c = glm::dot(oc, oc) - colliderMeasure1 * colliderMeasure1;

			float discriminant = b * b - 4 * a * c;

			// If the discriminant is non-negative, there is an intersection
			if (discriminant >= 0) {
				// Otherwise, calculate the distance along the ray to the intersection point
				float t1 = (-b - sqrt(discriminant)) / (2.0f * a);
				float t2 = (-b + sqrt(discriminant)) / (2.0f * a);

				// Return the smaller positive distance
				return std::min(t1, t2);
			}
		}
		else if (colliderMode == SelectionColliderMode::mesh) {
			// do a raycast against all triangles in the mesh
			size_t numTriangles = colliderMesh->indices.size() / 3;
			float minDist = std::numeric_limits<float>::quiet_NaN();
			for (size_t i = 0; i < numTriangles; ++i) {
				glm::vec3 v0 = colliderMesh->vertices[colliderMesh->indices[i * 3 + 0]].pos;
				glm::vec3 v1 = colliderMesh->vertices[colliderMesh->indices[i * 3 + 1]].pos;
				glm::vec3 v2 = colliderMesh->vertices[colliderMesh->indices[i * 3 + 2]].pos;
				glm::vec3 objPos = transformComponent->getGlobalTransform().getPosition();
				float dist = rayTriangleIntersect(rayOrigin, glm::normalize(rayDirection), v0 + objPos, v1 + objPos, v2 + objPos);
				// Keeps first non-NaN value, the keeps smallest subsequent value.
				// Probably a cleaner way to write this - but keeping for now because it works
				if (std::isnan(minDist)) {
					minDist = dist;
				}
				else if (!std::isnan(dist)) {
					if (dist < minDist) {
						minDist = dist;
					}
				}
			}
			return minDist;
		}

		return std::numeric_limits<float>::quiet_NaN();
	}
	
	void SetMouseoverState(bool state) {
		if (state != mouseoverState) {
			if (state) {
				OnMouseoverBegin();
			}
			else {
				OnMouseoverEnd();
			}
		}
		mouseoverState = state;
	}

	bool IsMouseovered() const {
		return mouseoverState;
	}

	bool IsSelected() const {
		return selectState;
	}

	bool IsDragable() const {
		return dragable;
	}
	
	bool IsBeingDragged() const {
		return dragState;
	}

	void SetDragState(bool state) {
		if (dragState != state) {
			if (state) {
				OnDragStart();
			}
			else {
				OnDragEnd();
			}
		}
		dragState = state;
	}

	virtual void OnDragStart() {};
	virtual void OnDragEnd() {};
	virtual void OnDrag(const glm::vec3& rayOrigin, const glm::vec3& rayDirection) {};
	virtual void OnSelect() {};
	virtual void OnDeselect() {};
	virtual void OnMouseoverBegin() {};
	virtual void OnMouseoverEnd() {};

	void Select() {
		selectState = true;
		OnSelect();
	}

	void Deselect() {
		selectState = false;
		OnDeselect();
	}

	SelectableActor();
	virtual ~SelectableActor();
};